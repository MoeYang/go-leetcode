#### 面试题 08.11. 硬币

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

示例1:
```
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```
示例2:
```
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```
说明：

注意:

你可以假设：

- 0 <= n (总金额) <= 1000000

#### 解法
完全背包问题，很容易得出递推式：
```
dp[i][j] = dp[i-1][j-0*coins[i]] + dp[i-1][j-1*coins[i]] + dp[i-1][j-2*coins[i]]... （j-k*coins[i] >= 0）
```
1、写出代码

2、化简：按递推式暴力写码，可知时间复杂度是```len(coins)*n*(j/coins[i])```的三重循环，

我们将原递推式化简成```dp[i][j]=dp[i−1][j] + dp[i][j−coins[i]]```,时间复杂度可以优化为2重循环

同理，发现dp[i][j]只与[i−1][j]和[j−coins[i]]有关，故空间复杂度可化简到一维

```go
func waysToChange(n int) int {
    dp := make([]int, n + 1)
    dp[0] = 1
    coins := []int{1, 5, 10, 25}
    for i := 0; i < 4; i++ {
        for j := 1; j <= n; j++ {
            if j - coins[i] >= 0 {
                dp[j] += dp[j - coins[i]]
            }
        }
    }
    return dp[n] % 1000000007
}
```