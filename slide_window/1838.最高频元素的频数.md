#### 1838. 最高频元素的频数
元素的 频数 是该元素在一个数组中出现的次数。

给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。

执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。

示例 1：
```
输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
```
示例 2：
```
输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
```
示例 3：
```
输入：nums = [3,9,6], k = 2
输出：1
```

提示：
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5
- 1 <= k <= 10^5

#### 解法
考虑[1,4,8,13]， 想要将1，4调整到8，很明显需要先操作4，再操作1. 基于此，我们可以对数组排序，之后对于每个下标i，考虑[0:i]能够调整成nums[i]的个数。

我们可以对j=(i-1,0)区间内的每个数字，计算nums[i]-nums[j],并统计是否在k的范围内。

但这样时间复杂度很明显是O(n*n),有没有什么优化空间？

考虑一下滑动窗口：定义i,j为窗口的左右边界，设[i,j]区间所有数字都变为nums[j]需要的步数为sum.

则sum>k的情况，我们需要把左边界右移；sum<=k的情况，我们可以把有边界右移，以扩大计算范围。

针对统计区间内sum的操作，我们可以通过先计算数组前缀和的方式來简化：

``sum = nums[j]*(j-i) - prefix(j-i)``

```go
func maxFrequency(nums []int, k int) int {
    sort.Ints(nums)
	prefix := make([]int, len(nums)+1)
	for i := range nums {
		prefix[i+1] = prefix[i] + nums[i]
	}
	left, right := 0, 0
    var max int
	for right < len(nums) {
		for nums[right]*(right-left)-(prefix[right]-prefix[left]) > k {
			left++
		}
		if right-left+1 > max {
			max = right - left + 1
		}
		right++
	}
	return max
}
```