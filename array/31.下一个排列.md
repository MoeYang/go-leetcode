#### 31. 下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

示例 1：
```
输入：nums = [1,2,3]
输出：[1,3,2]
```
示例 2：
```
输入：nums = [3,2,1]
输出：[1,2,3]
```
示例 3：
```
输入：nums = [1,1,5]
输出：[1,5,1]
```
示例 4：
```
输入：nums = [1]
输出：[1]
```

提示：
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 100

#### 解法
要求比当前数字更大的最小排列：如[1,2,5,3,1], 下一个最大排列是[1,3,1,2,5]

为了得到比当前数字大，但又是最小的数字，我们需要
1. 从右向左找到第一个交换下标i，这里是``nums[i]=2``，使得``nums[i]<nums[i+1]``，这样交换后数字可以变大
2. 我们直到2和5可以交换。但不确定还有没有比5更小的数字可以拿来和2交换，所以我们在5的右边遍历，找到``min(nums[j]...len(nums)) && nums[j]>2``。这里我们找到的是3
3. 交换后得到[1,3,5,2,1]，但这肯定不满足题意，我们还需要对idx=2后面的数字，按照升序排序，得到[1,3,1,2,5]，才是要求的数字
```go
func nextPermutation(nums []int) {
    n := len(nums)
    i := n - 2
    // 找到第一个数字，可以被交换的，这里是nums[i]=2
    for i >= 0 && nums[i] >= nums[i+1] {
        i--
    }
    if i >= 0 {
        // 从数组末尾向前，找到第一个>2的数字，这里是3
        j := n - 1
        for j >= 0 && nums[i] >= nums[j] {
            j--
        }
        // 交换2，3，得到[1,3,5,2,1]
        nums[i], nums[j] = nums[j], nums[i]
    }
    // 把5，2，1重排序
    reverse(nums[i+1:])
}

func reverse(a []int) {
    for i, n := 0, len(a); i < n/2; i++ {
        a[i], a[n-1-i] = a[n-1-i], a[i]
    }
}

```