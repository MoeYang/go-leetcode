#### 面试题 17.05.  字母与数字
给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。

示例 1:
```
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```
示例 2:
```
输入: ["A","A"]

输出: []
```
提示：
- array.length <= 100000

#### 解法
前缀和，遍历数组并统计[0, i]区间内的字符和数字个数，遇到字符+1， 遇到数字-1

这样，一旦遇到两个不同下标s,e的前缀和相等，我们认为字符串[s,e]是一个平衡串。

我们只要找到最长的平衡串即可。为了找到最长串，我们把首次出现的前缀和及对应下标存入map

```go
func findLongestSubarray(array []string) []string {
    if len(array) == 0 {
        return nil
    }
    m := make(map[int]int)
    m[0] = -1 // 初始化，认为字符串起始位置的前缀和=0
    var sum int
    var sIdx,eIdx = 0, -1
    for i, s := range array {
        if (s >= "A" && s <= "Z") || (s >= "a" && s <= "z") {
            sum++
        } else {
            sum--
        }
        if _, ok := m[sum]; !ok {
            m[sum] = i
            continue
        }
        // 存在同样的前缀和，则比较是否比已记录的平衡串更长
        if i - m[sum] > eIdx - sIdx + 1 {
            sIdx, eIdx = m[sum]+1, i
        }
    }
    return array[sIdx:eIdx+1]
}
```