### 2116. 判断一个括号字符串是否有效
一个括号字符串是只由 '(' 和 ')' 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：

- 字符串为 ().
- 它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。
- 它可以表示为 (A) ，其中 A 是一个有效括号字符串。
- 
给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked 是一个二进制字符串，只包含 '0' 和 '1' 。对于 locked 中 每一个 下标 i ：

- 如果 locked[i] 是 '1' ，你 不能 改变 s[i] 。
- 如果 locked[i] 是 '0' ，你 可以 将 s[i] 变为 '(' 或者 ')' 。
如果你可以将 s 变为有效括号字符串，请你返回 true ，否则返回 false 。

 

示例 1：


```
输入：s = "))()))", locked = "010100"
输出：true
解释：locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。
我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。
```
示例 2：
```
输入：s = "()()", locked = "0000"
输出：true
解释：我们不需要做任何改变，因为 s 已经是有效字符串了。
```
示例 3：
```
输入：s = ")", locked = "0"
输出：false
解释：locked 允许改变 s[0] 。
但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。
```

提示：

- n == s.length == locked.length
- 1 <= n <= 10^5
- s[i] 要么是 '(' 要么是 ')' 。
- locked[i] 要么是 '0' 要么是 '1' 。

### 解法
首先 s 长度不能为奇数，此时应直接返回 false。

然后就是用括号问题的经典技巧了：判断 s 是否为有效括号字符串，可以正序遍历 s，用一个变量 x 记录括号的平衡度，遇到左括号就加一，右括号就减一。要求 x 在任意时刻不能是负数，且遍历结束时 x=0

本题可以将部分括号变成左括号或者右括号（下文称作可变括号），我们可以将这些可变括号的个数暂存下来（不改变 x 的值），如果后面遇到 x 要变为负数的情况，则将前面的一个可变括号变为左括号，若此时没有剩余的可变括号，则说明我们无法将 s 变为有效括号字符串。

如果遍历结束后还剩下可变括号，可以将其与其他可变括号配对，或者与剩下的左括号配对。这种配对方式可以让最终的 x=0。但是这种做法会漏掉左括号比右括号多的情况，这种情况下我们是无法区分 *( 和 )* 的，这里 * 表示可变括号，所以我们还需要反着再遍历一次，从而涵盖所有情况。

代码实现时可以将 x 和可变括号的个数合并成同一个变量。
```go
func canBeValid(s string, locked string) bool {
    // 奇数肯定配不平
    if len(s)%2 != 0 {
        return false
    }
    var sum int 
    for i := range s {
        // 左括号或可变括号，都当成左括号
        if s[i] == '(' || locked[i] == '0' {
            sum++
        } else {
            // 右括号多，一定失败
            sum--
            if sum < 0 {
                return false
            }
        }
    }
    sum = 0 
    for i := len(s)-1; i >= 0; i-- {
        // 右括号或可变括号，都当成右括号
        if s[i] == ')' || locked[i] == '0' {
            sum++
        } else {
            // 左括号多，一定失败
            sum--
            if sum < 0 {
                return false
            }
        }
    }
    return true
}
```